#!/usr/bin/python
#
#    testdrive - run today's Ubuntu development ISO, in a virtual machine
#    Copyright (C) 2009 Canonical Ltd.
#    Copyright (C) 2009 Dustin Kirkland
#
#    Authors: Dustin Kirkland <kirkland@canonical.com>
#             Andres Rodriguez <andreserl@ubuntu.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

import commands, hashlib, os, string, sys, tempfile, time, platform, testdrive
from optparse import OptionParser

# Creates the UI list
def select_iso(td, ISO):
	while 1:
		i = 1
		print("\nWelcome to Testdrive!\n")
		for iso in ISO:
			print("  %d. %s" % (i, iso["name"]))
			filename = os.path.basename(iso["url"])
			path = "%s/%s" % (td.CACHE_ISO, filename)
			if os.path.exists(path):
				print("     +-cache--> [%s] %s" % (time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(os.path.getmtime(path))), filename))
			i=i+1
		print("  %d. Other (prompt for ISO URL)" % i)
		try:
			input = raw_input("\nSelect an image to testdrive [1]: ")
			if len(input) == 0:
				choice = 1
			else:
				choice = int(input)
		except KeyboardInterrupt:
			print("\n")
			exit(0)
		except:
			print("\nERROR: Invalid input\n")
			continue
		if choice == i:
			url = raw_input("\nEnter an ISO URL to testdrive: ")
			break
		elif choice in range(1, i):
			url = ISO[choice-1]["url"]
			break
		else:
			print("\nERROR: Invalid selection\n")
	return(url)

def error(str):
	print("\nERROR: %s\n" % str)
	sys.exit(1)

def info(str):
	print("INFO: %s" % str)

def warning(str):
	print("WARNING: %s" % str)

def is_iso(file):
	# If it's a URL, assume it's good
	for i in ("http", "ftp", "rsync", "file"):
		if string.find(file, "%s://" % i) == 0:
			return(file)
	# If it's a local path, test it for viability
	if commands.getstatusoutput("file \"%s\" | grep -qs \"ISO 9660\"" % file)[0] == 0:
		return("file://%s" % file)
	else:
		error("Invalid ISO URL [%s]" % file)

def run(cmd):
	return(os.system(cmd))

def run_or_die(cmd):
	if run(cmd) != 0:
		error("Command failed\n    `%s`" % cmd)

def launch_kvm(td):
	(status, output) = commands.getstatusoutput("kvm-ok")
	if status != 0:
		print(output)
	info("Creating disk image [%s]..." % td.DISK_FILE)
	run_or_die("kvm-img create -f qcow2 %s %s" % (td.DISK_FILE, td.DISK_SIZE))
	info("Running the Virtual Machine...")
	os.system("kvm -m %s -cdrom %s -drive file=%s,if=virtio,index=0,boot=on %s" % (td.MEM, td.PATH_TO_ISO, td.DISK_FILE, td.KVM_ARGS))

def launch_virtualbox(td):
	# Determine which version of VirtualBox we have installed.  What is returned is
	# typically a string such as '3.1.0r55467', lets assume that the command line
	# is consistent within 3.0.x versions and 3.1.x version so extract this part of the
	# version string for comparison later
	vboxversion = commands.getoutput("VBoxManage --version")
	vboxversion = "%s.%s" % (vboxversion.split(".")[0], vboxversion.split(".")[1])
	if vboxversion == "3.0" or vboxversion == "3.1":
		info("VirtualBox %s detected." % vboxversion)
	else:
		error("Unsupported version (%s) of VirtualBox; please install v3.0 or v3.1." % vboxversion)

	td.DISK_SIZE = td.DISK_SIZE.replace("G", "000")
	if os.path.exists(td.DISK_FILE):
		os.unlink(td.DISK_FILE)
	run("sed -i \":HardDisk.*%s:d\" %s/.VirtualBox/VirtualBox.xml" % (td.DISK_FILE, td.HOME))
	info("Creating disk image...")
	run_or_die("VBoxManage createhd --filename %s --size %s" % (td.DISK_FILE, td.DISK_SIZE))
	if vboxversion == "3.0":
		run("VBoxManage modifyvm %s --hda none" % td.VBOX_NAME)
	elif vboxversion == "3.1":
		run("VBoxManage storageattach %s --storagectl \"IDE Controller\" --port 0 --device 0 --type hdd --medium none" % td.VBOX_NAME)
		run("VBoxManage storageattach %s --storagectl \"IDE Controller\" --port 0 --device 1 --type dvddrive --medium none" % td.VBOX_NAME)
	info("Creating the Virtual Machine...")
	if os.path.exists("%s/.VirtualBox/Machines/%s/%s.xml" % (td.HOME, td.VBOX_NAME, td.VBOX_NAME)):
		os.unlink("%s/.VirtualBox/Machines/%s/%s.xml" % (td.HOME, td.VBOX_NAME, td.VBOX_NAME))
	run("VBoxManage unregistervm %s --delete" % td.VBOX_NAME)
	run_or_die("VBoxManage createvm --register --name %s" % td.VBOX_NAME)
	run_or_die("VBoxManage modifyvm %s --memory %s" % (td.VBOX_NAME, td.MEM))
	# This should probably support more than just Ubuntu...
	if td.ISO_URL.find("amd64") >= 0:
		platform = "Ubuntu_64"
	else:
		platform = "Ubuntu"
	run_or_die("VBoxManage modifyvm %s --ostype %s" % (td.VBOX_NAME, platform))
	run_or_die("VBoxManage modifyvm %s --vram 128" % td.VBOX_NAME)
	run_or_die("VBoxManage modifyvm %s --boot1 disk" % td.VBOX_NAME)
	run_or_die("VBoxManage modifyvm %s --boot2 dvd" % td.VBOX_NAME)
	run_or_die("VBoxManage modifyvm %s --nic1 nat" % td.VBOX_NAME)
	info("Running the Virtual Machine...")
	if vboxversion == "3.0":
		run_or_die("VBoxManage modifyvm %s --hda %s" % (td.VBOX_NAME, td.DISK_FILE))
		run_or_die("VBoxManage startvm %s" % td.VBOX_NAME)
		print(">>> %s <<<\n" % (td.PATH_TO_ISO))
		run_or_die("VBoxManage controlvm %s dvdattach %s" % (td.VBOX_NAME, td.PATH_TO_ISO))
	elif vboxversion == "3.1":
		run_or_die("VBoxManage storagectl %s --name \"IDE Controller\" --add ide" % td.VBOX_NAME)
		run_or_die("VBoxManage storageattach %s --storagectl \"IDE Controller\" --port 0 --device 0 --type hdd --medium %s" % (td.VBOX_NAME, td.DISK_FILE))
		run_or_die("VBoxManage storageattach %s --storagectl \"IDE Controller\" --port 0 --device 1 --type dvddrive --medium %s" % (td.VBOX_NAME, td.PATH_TO_ISO))
		run_or_die("VBoxManage startvm %s" % td.VBOX_NAME)

	# Give this VM a few seconds to start up
	time.sleep(5)
	# Loop as long as this VM is running
	while commands.getstatusoutput("VBoxManage list runningvms | grep -qs %s" % td.VBOX_NAME)[0] == 0:
		time.sleep(2)

def launch_parallels(td):
	if commands.getstatusoutput("prlctl list %s | grep -qsv \"UUID\"" % td.VBOX_NAME)[0] == 0:
		run_or_die("prlctl delete %s" % td.VBOX_NAME)
	td.DISK_SIZE = td.DISK_SIZE.replace("G", "000")
	info("Creating VM...")
	run_or_die("prlctl create %s --ostype linux --distribution ubuntu" % td.VBOX_NAME)
	run_or_die("prlctl set %s --memsize %s" % (td.VBOX_NAME, td.MEM))
	run_or_die("prlctl set %s --device-del hdd0" % td.VBOX_NAME)
	run_or_die("prlctl set %s --device-add hdd --type expand --size %s --iface scsi --position 0:0" % (td.VBOX_NAME, td.DISK_SIZE))
	run_or_die("prlctl set %s --device-set cdrom0 --image %s" % (td.VBOX_NAME, td.PATH_TO_ISO))
	run_or_die("prlctl start %s" % td.VBOX_NAME)
	# Loop as long as this VM is running
	while commands.getstatusoutput("prlctl list %s | grep -qs stopped" % td.VBOX_NAME)[0] != 0:
		time.sleep(2)

def main():
	# Initialize Testdrive Class
	td = testdrive.Testdrive()

	# Local UI
	hasOptions = False

	# Codename cache variables
	update_cache = None
	codename = None

	# Option Parser
	usage = "usage: %prog <parameters>\n\
		\n\
		%prog is a utility that allows you to easily download the latest Ubuntu\n\
		development release and run it in a KVM virtual machine.\n\
		\n\
		All options to this program are handled through the global configuration\n\
		file, /etc/%progrc, and then the user's local configuration file,\n\
		~/.%progrc, then the configuration stored in\n\
		~/.config/%prog/%progrc\n\
		\n\
		Users wanting to change the behavior default configuration can make a\n\
		copy of /etc/%s, and pass this as a parameter to %prog.\n"


	parser = OptionParser(usage)
	parser.add_option('-f', '--config', action='store', type='string', dest='config',
		help='user configuration file (overriding default values')
	parser.add_option('-v', '--version', action='store_true', dest='version', default=False,
		help='print version and system data, and exit')
	parser.add_option('-u', '--url', action='store', type='string', dest='url', 
		help='get ISO image from this URL location')
	parser.add_option('-d', '--desktop', action='store_true', dest='desktop', default=False,
		help='try to launch usb-creator for further testing')
	parser.add_option('-r', '--release', action='store', type='string', dest='release',
		help='hardcode Ubuntu RELEASE codename')

	(opt, args) = parser.parse_args()
	info("version passed: %s" % opt.version)
	if opt.version:
		hasOptions = True
		version = commands.getstatusoutput("dpkg -l testdrive | tail -n1 | awk '{print $3}'")
		info("testdrive %s" % version[1])
		#TODO: Why is get_virt() here? Disable until is determined if we really need it or not. If yes, we'll have to add same code as below,
		# for same function
		td.get_virt()
		sys.exit(0)

	# TODO: is_iso function is locally used to see if the url is indeed one or not. Could be used by the front-end
	# Process the rest of the options
	if opt.url:
		hasOptions = True
		td.ISO_URL = is_iso(opt.url)

	# prime configuration with defaults
	config_files = ["/etc/%s" % td.PKGRC, "%s/.%s" % (td.HOME, td.PKGRC), "%s/.config/%s/%s" % (td.HOME, td.PKG, td.PKGRC) ]
	info("config passed: %s" %opt.config)
	if opt.config:
		hasOptions = True
		if opt.config[0] != '/':
			opt.config = '%s/.config/%s/%s' % (td.HOME, td.PKG, opt.config)
		config_files += [opt.config]

	# try to load configuration files; on error exit
	# Let the user know which config files were used
	for i in config_files:
		info('Trying config in %s' % i)
		if os.path.exists(i):
			try:
				td.load_config_file(i)
				info("Using configuration in %s" % i)
			except:
				error("Invalid configuration [%s]" % i)

	# Launch usb-creator
	if opt.desktop:
		hasOptions = True
		DESKTOP = 1
	else:
		DESKTOP = 0

	# Harcoded release codename from executable. Overrides value in config file
	if opt.release:
		hasOptions = True
		td.r = opt.release

	# Handle single positional parameter
	if not hasOptions:
		if args:
			td.ISO_URL = is_iso(args)

	# Choose the virtualization engine
	if not td.VIRT:
		td.VIRT = td.get_virt()
	#NOTICE: Removed from get_virt() and placed here
	if td.VIRT == 1:
		error("Your CPU supports KVM acceleration; please install KVM:\n\
			sudo apt-get install qemu-kvm")
	if td.VIRT == 0:
		error("Your CPU does not support acceleration; run kvm-ok for more information; then please install VirtualBox:\n\
			kvm-ok\n\
			sudo apt-get install virtualbox-ose")
	if td.VIRT == "kvm":
		info("Using KVM for virtual machine hosting...");
	if td.VIRT == "virtualbox":
		info("Using VirtualBox for virtual machine hosting...")
	if td.VIRT == "paralels":
		info("Using Parallels Desktop for virtual machine hosting...")

	# set defaults were undefined
	td.set_defaults()

	## Obtain Ubuntu Devel Release Codename ##
	if not td.r:
		# Verify if the codename is cached, if not, set variable to update/create it
		if td.is_codename_cached() is False:
			update_cache = 1
		# If codename cached, verify if it is expired. If it is, set variable to update it.
		elif td.is_cache_expired() is True:
			update_cache = 1

		# If variable set to update, obtain release from launchpad
		if update_cache == 1:
			info("Obtaining Ubuntu Development Release codename from Launchpad...")
			try:
				codename = td.lp_obtain_release_codename()
			except:
				print "ERROR: Could not obtain the Ubuntu Development Release codename from Launchpad..."

		# If release was obtained, update the cache file
		if codename:
			try:
				td.update_ubuntu_codename_cache(codename)
			except:
				error("Unable to update Ubuntu Development Release codename cache.")

		# Try to retrieve Ubuntu Devel codename from cache
		info("Retrieving Ubuntu Development Release codename from cache...")
		try:
			td.r = td.get_ubuntu_codename()
		except:
			error("Unable to retrieve Ubuntu Development Release codename from cache...")

	# Select all ISO's
	ISO = td.list_isos()

	# Show the Command Line MENU and OBTAIN URL
	#if len(ISO_URL) == 0:
	if not td.ISO_URL:
		td.ISO_URL = select_iso(td, ISO)

	# Setting launch path. Comes from merging rev 189
	td.set_launch_path()

	# BUG: should check disk space availability in CACHE dir
	# Update the cache
	info("Syncing the specified ISO...")
	print("      %s" % td.ISO_URL)
	cmd = td.get_proto()
	if cmd == 1:
		error("ISO not found at [%s]" % td.ISO_URL)
	elif cmd == 2:
		error("Unsupported protocol [%s]" % td.PROTO)
	if cmd != 0:
		run_or_die(cmd)

	# Launch the VM
	if td.VIRT == "kvm":
		launch_kvm(td)
	elif td.VIRT == "virtualbox":
		launch_virtualbox(td)
	elif td.VIRT == "parallels":
		launch_parallels(td)
	else:
		error("Unsupported virtualization method [%s]" % td.VIRT)

	rm_disk = td.delete_image()
	if rm_disk:
		info("Cleaning up disk image [%s]..." % td.DISK_FILE)

	# Remind about cache cleanup
	info("You may wish to clean up the cache directory...")
	print("      %s and %s" % (td.CACHE_ISO, td.CACHE_IMG))
	#run("ls -HhalF %s %s" % (CACHE_ISO, CACHE_IMG))
	#run("du -sh --apparent-size %s %s 2>/dev/null || du -sh %s %s" % (CACHE_ISO, CACHE_IMG))

	# Launch Desktop
	if DESKTOP == 1:
		if os.path.exists("/usr/bin/usb-creator-gtk") or os.path.exists("/usr/bin/usb-creator-kde"):
			input = raw_input("\nLaunch USB Startup Disk Creator for further testing of this ISO? [y/N] ")
			if input == "y" or input == "Y":
				td.launch_usb_creator()
		else:
			raw_input("\nPress <enter> to exit...")

	sys.exit(0)

if __name__ == '__main__':
	main()
