#!/bin/sh -e
#
#    testdrive - run today's Ubuntu development ISO, in a virtual machine
#    Copyright (C) 2009 Canonical Ltd.
#    Copyright (C) 2009 Dustin Kirkland
#
#    Authors: Dustin Kirkland <kirkland@canonical.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

PKG="testdrive"
PKGRC=$PKG"rc"

usage() {
	echo "
Usage:
  $PKG [-f CONFIG_FILE] [-u URL_TO_ISO]

  $PKG is a utility that allows you to easily download the latest Ubuntu
  development release and run it in a KVM virtual machine.

  All options to this program are handled through the global configuration
  file, /etc/$PKGRC, and then the user's local configuration file,
  ~/.$PKGRC.

  Users wanting to change the behavior default configuration can make a
  copy of /etc/$PKGRC, and pass this as a parameter to $PKG.
"
	exit 1
}

# Source global configuration overrides
[ -r "/etc/$PKG"rc ] && . "/etc/$PKG"rc

# Source user configuration overrides
[ -r "$HOME/.$PKG"rc ] && . "$HOME/.$PKG"rc

# Source xdg user configuration overrides
[ -r "$HOME/.config/$PKG/$PKG"rc ] && . "$HOME/.$PKG"rc

# Handle parameters
while [ -n "$1" ]; do
	case "$1" in
		-f)
			[ -r "$2" ] && . "$2" || usage
			shift 2
		;;
		-u)
			ISO_URL="$2"
			shift 2
			if ! echo "$ISO_URL" | grep -qs "\.iso$"; then
				echo "ERROR: URL parameter must point to a .iso file" 1>&2
				exit 1
			fi
			if [ -r "$ISO_URL" ]; then
				# arg is a path to a local file
				ISO_URL="file://$ISO_URL"
			fi
		;;
		*)
			usage
		;;
	esac
done

# If the ISO URL is undefined, make a selection, and then relaunch
[ -z "$ISO_URL" ] && exec testdrive-select-iso

# Choose the virtualization engine
if [ -z "$VIRT" ]; then
	# Check if KVM acceleration can be used
	if which kvm-ok >/dev/null && kvm-ok >/dev/null 2>&1; then
		VIRT="kvm"
		echo
		echo "INFO: Using KVM for virtual machine hosting..."
		echo
	elif which VBoxManage >/dev/null; then
		echo
		echo "WARNING: Your CPU's lack of VT will seriously impact performance."
		echo "INFO: Using VirtualBox for virtual machine hosting..."
		echo
		VIRT="virtualbox"
	elif which prlctl >/dev/null; then
		VIRT="parallels"
		echo
		echo "INFO: Using Parallels Desktop for virtual machine hosting..."
		echo
	else
		echo
		echo "ERROR: You must have either /usr/bin/kvm or /usr/bin/VBoxManage installed."
		echo "HINT: Consider installing kvm if your CPU supports VT, or virtualbox-ose..."
		echo " egrep \"flags.*:.*(svm|vmx)\" /proc/cpuinfo && \\"
		echo "   sudo apt-get install kvm || \\"
		echo "   sudo apt-get install virtualbox-ose"
		echo
		exit 1
	fi
fi

# Set defaults where undefined
[ -z "$CACHE" ] && CACHE="$HOME/.cache/$PKG"
mkdir -p $CACHE/iso $CACHE/img
ISO=$(echo "$ISO_URL" | sed "s:.*/::")
PROTO=$(echo "$ISO_URL" | sed "s/:.*$//")
[ -z "$MEM" ] && [ $(grep "^MemTotal" /proc/meminfo | awk '{print $2}') -gt 1000000 ] && MEM=512 || MEM=256
[ -z "$DISK_FILE" ] && DISK_FILE=$(mktemp $CACHE/img/$PKG-disk-XXXXXX) && mv -i $DISK_FILE $DISK_FILE.img && DISK_FILE=$DISK_FILE.img
[ -z "$DISK_SIZE" ] && DISK_SIZE=6G
[ -z "$KVM_ARGS" ] && KVM_ARGS="-usb -usbdevice tablet -net nic,model=virtio -net user -soundhw es1370"
[ -z "$VBOX_NAME" ] && VBOX_NAME="$PKG"
PATH_TO_ISO="$CACHE/iso/$ISO"

# BUG: should check disk space availability in $CACHE dir
# Update the cache
echo
echo "INFO: Syncing the specified ISO..."
echo "      $ISO_URL"
case $PROTO in
	rsync)
		rsync -azP $ISO_URL $PATH_TO_ISO
	;;
	http|ftp)
		ZSYNC_WORKED=0
		if which zsync >/dev/null; then
			cd $CACHE/iso
			zsync $ISO_URL.zsync && ZSYNC_WORKED=1 || true
			cd -
		fi
		if [ "$ZSYNC_WORKED" = "0" ]; then
			# If the zsync failed, use wget
			wget $ISO_URL -O $PATH_TO_ISO
		fi
	;;
	file)
		# If the iso is on file:///, use the ISO in place
		PATH_TO_ISO=$(echo $ISO_URL | sed "s/^file:\/\///")
		DIR=$(cd "$(dirname "$PATH_TO_ISO")"; pwd)
		FILE=$(basename "$PATH_TO_ISO")
		PATH_TO_ISO="$DIR/$FILE"
	;;
	*)
		echo "ERROR: Unsupported protocol [$PROTO]" 1>&2
		exit 1
	;;
esac

# Launch the VM
case $VIRT in
	kvm)
		echo
		echo "INFO: Creating disk image..."
		kvm-img create -f qcow2 $DISK_FILE $DISK_SIZE
		echo
		if ! out=$(kvm-ok 2>&1); then
			echo "$out"
		fi
		echo "INFO: Running the Virtual Machine..."
		kvm -m $MEM -cdrom $PATH_TO_ISO -drive file=$DISK_FILE,if=virtio,index=0,boot=on $KVM_ARGS
	;;
	virtualbox)
	       	# Determine which version of VirtualBox we have installed.  What is returned is
		# typically a string such as '3.1.0r55467', lets assume that the command line
		# is consistent within 3.0.x versions and 3.1.x version so extract this part of the
		# version string for comparison later
		vboxversion=$(VBoxManage --version)
		vboxversion=${vboxversion%.*}
		case $vboxversion in
			"3.0"|"3.1")
				echo
				echo "INFO: VirtualBox $vboxversion detected."
			;;
			*)
				echo
				echo "INFO: Unsupported version of VirtualBox; pleast install v3.0 or v3.1."
				exit 1
			;;
		esac
		DISK_SIZE=$(echo "$DISK_SIZE" | sed "s/G$/000/")
		rm -f $DISK_FILE
		sed -i "\:HardDisk.*$DISK_FILE:d" $HOME/.VirtualBox/VirtualBox.xml 2>/dev/null || true
		echo
		echo "INFO: Creating disk image..."
		VBoxManage createhd --filename $DISK_FILE --size $DISK_SIZE
		case $vboxversion in
			"3.0")
				VBoxManage modifyvm $VBOX_NAME --hda none >/dev/null || true
				rm -f $HOME/.VirtualBox/Machines/$VBOX_NAME/$VBOX_NAME.xml
			;;
			"3.1")
				VBoxManage storageattach $VBOX_NAME --storagectl "IDE Controller" --port 0 --device 0 --type hdd --medium none >/dev/null || true
				VBoxManage storageattach $VBOX_NAME --storagectl "IDE Controller" --port 0 --device 1 --type dvddrive --medium none >/dev/null || true
			;;
		esac
		echo
		echo "INFO: Creating the Virtual Machine..."
		VBoxManage unregistervm $VBOX_NAME --delete >/dev/null || true
		VBoxManage createvm --register --name $VBOX_NAME
		VBoxManage modifyvm $VBOX_NAME --memory $MEM
#		case $vboxversion in
#			"3.0") VBoxManage modifyvm $VBOX_NAME --hda $DISK_FILE ;;
#		esac
		platform=$(echo $ISO_URL | grep -qs amd64 && echo Ubuntu_64 || echo Ubuntu)
		VBoxManage modifyvm $VBOX_NAME --ostype $platform
		VBoxManage modifyvm $VBOX_NAME --vram 128
		VBoxManage modifyvm $VBOX_NAME --boot1 disk
		VBoxManage modifyvm $VBOX_NAME --boot2 dvd
		VBoxManage modifyvm $VBOX_NAME --nic1 nat
		echo
		echo "INFO: Running the Virtual Machine..."
		case $vboxversion in
			"3.0")
				VBoxManage modifyvm $VBOX_NAME --hda $DISK_FILE
				VBoxManage startvm $VBOX_NAME
				echo ">>>$PATH_TO_ISO<<<"
				VBoxManage controlvm $VBOX_NAME dvdattach $PATH_TO_ISO
			;;
			"3.1")
				VBoxManage storagectl $VBOX_NAME --name "IDE Controller" --add ide
				VBoxManage storageattach $VBOX_NAME --storagectl "IDE Controller" --port 0 --device 0 --type hdd --medium $DISK_FILE
				VBoxManage storageattach $VBOX_NAME --storagectl "IDE Controller" --port 0 --device 1 --type dvddrive --medium $PATH_TO_ISO
				VBoxManage startvm $VBOX_NAME
			;;
		esac

		# Loop as long as this VM is running
		while true; do
			sleep 2
			if ! VBoxManage list runningvms | grep -qs "^\"$VBOX_NAME\""; then
				break
			fi
		done
	;;
	parallels)
		echo
		if prlctl list $VBOX_NAME | grep -qsv "UUID"; then
			prlctl delete $VBOX_NAME
		fi
		DISK_SIZE=$(echo "$DISK_SIZE" | sed "s/G$/000/")
		echo "INFO: Creating VM..."
		prlctl create $VBOX_NAME --ostype linux --distribution ubuntu
		prlctl set $VBOX_NAME --memsize $MEM
		prlctl set $VBOX_NAME --device-del hdd0
		prlctl set $VBOX_NAME --device-add hdd --type expand --size $DISK_SIZE --iface scsi --position 0:0
		prlctl set $VBOX_NAME --device-set cdrom0 --image $PATH_TO_ISO
		prlctl start $VBOX_NAME
		# Loop as long as this VM is running
		while true; do
			sleep 2
			if prlctl list $VBOX_NAME | grep -qs "stopped"; then
				break
			fi
		done
	;;
	*)
		echo "ERROR: Unsupported virtualization method [$VIRT]"
	;;
esac

# Remind about cache cleanup
echo
echo "INFO: You may wish to clean up the cache directory..."
echo "      $CACHE"
ls -HhalF $CACHE/iso $CACHE/img
du -sh --apparent-size $CACHE 2>/dev/null || du -sh $CACHE
echo
